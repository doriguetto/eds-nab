{"version":3,"file":"props.BuiaX4zr.js","sources":["../../node_modules/svelte/src/internal/client/dom/blocks/each.js","../../node_modules/svelte/src/internal/client/reactivity/store.js","../../node_modules/svelte/src/internal/client/reactivity/props.js"],"sourcesContent":["/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */\nimport {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_ITEM_IMMUTABLE,\n\tEACH_ITEM_REACTIVE,\n\tHYDRATION_END,\n\tHYDRATION_START_ELSE\n} from '../../../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling\n} from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\trun_out_transitions,\n\tpause_children,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, internal_set } from '../../reactivity/sources.js';\nimport { array_from, is_array } from '../../../shared/utils.js';\nimport { INERT } from '../../constants.js';\nimport { queue_micro_task } from '../task.js';\nimport { active_effect } from '../../runtime.js';\n\n/**\n * The row of a keyed each block that is currently updating. We track this\n * so that `animate:` directives have something to attach themselves to\n * @type {EachItem | null}\n */\nexport let current_each_item = null;\n\n/** @param {EachItem | null} item */\nexport function set_current_each_item(item) {\n\tcurrent_each_item = item;\n}\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {EachState} state\n * @param {EachItem[]} items\n * @param {null | Node} controlled_anchor\n * @param {Map<any, EachItem>} items_map\n */\nfunction pause_effects(state, items, controlled_anchor, items_map) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = items.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tpause_children(items[i].e, transitions, true);\n\t}\n\n\tvar is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;\n\t// If we have a controlled anchor, it means that the each block is inside a single\n\t// DOM element, so we can apply a fast-path for clearing the contents of the element.\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (\n\t\t\t/** @type {Element} */ (controlled_anchor).parentNode\n\t\t);\n\t\tclear_text_content(parent_node);\n\t\tparent_node.append(/** @type {Element} */ (controlled_anchor));\n\t\titems_map.clear();\n\t\tlink(state, items[0].prev, items[length - 1].next);\n\t}\n\n\trun_out_transitions(transitions, () => {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar item = items[i];\n\t\t\tif (!is_controlled) {\n\t\t\t\titems_map.delete(item.k);\n\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t}\n\t\t\tdestroy_effect(item.e, !is_controlled);\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\tvar anchor = node;\n\n\t/** @type {EachState} */\n\tvar state = { flags, items: new Map(), first: null };\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (node);\n\n\t\tanchor = hydrating\n\t\t\t? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))\n\t\t\t: parent_node.appendChild(create_text());\n\t}\n\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\t/** @type {Effect | null} */\n\tvar fallback = null;\n\n\tvar was_empty = false;\n\n\tblock(() => {\n\t\tvar collection = get_collection();\n\n\t\tvar array = is_array(collection)\n\t\t\t? collection\n\t\t\t: collection == null\n\t\t\t\t? []\n\t\t\t\t: array_from(collection);\n\n\t\tvar length = array.length;\n\n\t\tif (was_empty && length === 0) {\n\t\t\t// ignore updates if the array is empty,\n\t\t\t// and it already was empty on previous run\n\t\t\treturn;\n\t\t}\n\t\twas_empty = length === 0;\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;\n\n\t\t\tif (is_else !== (length === 0)) {\n\t\t\t\t// hydration mismatch — remove the server-rendered DOM and start over\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\t// this is separate to the previous block because `hydrating` might change\n\t\tif (hydrating) {\n\t\t\t/** @type {EachItem | null} */\n\t\t\tvar prev = null;\n\n\t\t\t/** @type {EachItem} */\n\t\t\tvar item;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tif (\n\t\t\t\t\thydrate_node.nodeType === 8 &&\n\t\t\t\t\t/** @type {Comment} */ (hydrate_node).data === HYDRATION_END\n\t\t\t\t) {\n\t\t\t\t\t// The server rendered fewer items than expected,\n\t\t\t\t\t// so break out and continue appending non-hydrated items\n\t\t\t\t\tanchor = /** @type {Comment} */ (hydrate_node);\n\t\t\t\t\tmismatch = true;\n\t\t\t\t\tset_hydrating(false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvar value = array[i];\n\t\t\t\tvar key = get_key(value, i);\n\t\t\t\titem = create_item(hydrate_node, state, prev, null, value, key, i, render_fn, flags);\n\t\t\t\tstate.items.set(key, item);\n\n\t\t\t\tprev = item;\n\t\t\t}\n\n\t\t\t// remove excess nodes\n\t\t\tif (length > 0) {\n\t\t\t\tset_hydrate_node(remove_nodes());\n\t\t\t}\n\t\t}\n\n\t\tif (!hydrating) {\n\t\t\treconcile(array, state, anchor, render_fn, flags, get_key);\n\t\t}\n\n\t\tif (fallback_fn !== null) {\n\t\t\tif (length === 0) {\n\t\t\t\tif (fallback) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t\t}\n\t\t\t} else if (fallback !== null) {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// When we mount the each block for the first time, the collection won't be\n\t\t// connected to this effect as the effect hasn't finished running yet and its deps\n\t\t// won't be assigned. However, it's possible that when reconciling the each block\n\t\t// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the\n\t\t// collection again can provide consistency to the reactive graph again as the deriveds\n\t\t// will now be `CLEAN`.\n\t\tget_collection();\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * Add, remove, or reorder items output by an each block as its input changes\n * @template V\n * @param {Array<V>} array\n * @param {EachState} state\n * @param {Element | Comment | Text} anchor\n * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>) => void} render_fn\n * @param {number} flags\n * @param {(value: V, index: number) => any} get_key\n * @returns {void}\n */\nfunction reconcile(array, state, anchor, render_fn, flags, get_key) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\tvar should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar first = state.first;\n\tvar current = first;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar seen;\n\n\t/** @type {EachItem | null} */\n\tvar prev = null;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar to_animate;\n\n\t/** @type {EachItem[]} */\n\tvar matched = [];\n\n\t/** @type {EachItem[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {EachItem | undefined} */\n\tvar item;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\titem = items.get(key);\n\n\t\t\tif (item !== undefined) {\n\t\t\t\titem.a?.measure();\n\t\t\t\t(to_animate ??= new Set()).add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\t\titem = items.get(key);\n\n\t\tif (item === undefined) {\n\t\t\tvar child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;\n\n\t\t\tprev = create_item(\n\t\t\t\tchild_anchor,\n\t\t\t\tstate,\n\t\t\t\tprev,\n\t\t\t\tprev === null ? state.first : prev.next,\n\t\t\t\tvalue,\n\t\t\t\tkey,\n\t\t\t\ti,\n\t\t\t\trender_fn,\n\t\t\t\tflags\n\t\t\t);\n\n\t\t\titems.set(key, prev);\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\tcurrent = prev.next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (should_update) {\n\t\t\tupdate_item(item, value, i, flags);\n\t\t}\n\n\t\tif ((item.e.f & INERT) !== 0) {\n\t\t\tresume_effect(item.e);\n\t\t\tif (is_animated) {\n\t\t\t\titem.a?.unfix();\n\t\t\t\t(to_animate ??= new Set()).delete(item);\n\t\t\t}\n\t\t}\n\n\t\tif (item !== current) {\n\t\t\tif (seen !== undefined && seen.has(item)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(state, a.prev, b.next);\n\t\t\t\t\tlink(state, prev, a);\n\t\t\t\t\tlink(state, b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(item);\n\t\t\t\t\tmove(item, current, anchor);\n\n\t\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t\t\tlink(state, item, prev === null ? state.first : prev.next);\n\t\t\t\t\tlink(state, prev, item);\n\n\t\t\t\t\tprev = item;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current.k !== key) {\n\t\t\t\t// If the item has an effect that is already inert, skip over adding it\n\t\t\t\t// to our seen Set as the item is already being handled\n\t\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\t\t(seen ??= new Set()).add(current);\n\t\t\t\t}\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titem = current;\n\t\t}\n\n\t\tmatched.push(item);\n\t\tprev = item;\n\t\tcurrent = item.next;\n\t}\n\n\tif (current !== null || seen !== undefined) {\n\t\tvar to_destroy = seen === undefined ? [] : array_from(seen);\n\n\t\twhile (current !== null) {\n\t\t\t// Inert effects are currently outroing and will be removed once the transition is finished\n\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\tto_destroy.push(current);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\n\t\tvar destroy_length = to_destroy.length;\n\n\t\tif (destroy_length > 0) {\n\t\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\t\tif (is_animated) {\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.measure();\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.fix();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpause_effects(state, to_destroy, controlled_anchor, items);\n\t\t}\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (to_animate === undefined) return;\n\t\t\tfor (item of to_animate) {\n\t\t\t\titem.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n\n\t/** @type {Effect} */ (active_effect).first = state.first && state.first.e;\n\t/** @type {Effect} */ (active_effect).last = prev && prev.e;\n}\n\n/**\n * @param {EachItem} item\n * @param {any} value\n * @param {number} index\n * @param {number} type\n * @returns {void}\n */\nfunction update_item(item, value, index, type) {\n\tif ((type & EACH_ITEM_REACTIVE) !== 0) {\n\t\tinternal_set(item.v, value);\n\t}\n\n\tif ((type & EACH_INDEX_REACTIVE) !== 0) {\n\t\tinternal_set(/** @type {Value<number>} */ (item.i), index);\n\t} else {\n\t\titem.i = index;\n\t}\n}\n\n/**\n * @template V\n * @param {Node} anchor\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>) => void} render_fn\n * @param {number} flags\n * @returns {EachItem}\n */\nfunction create_item(anchor, state, prev, next, value, key, index, render_fn, flags) {\n\tvar previous_each_item = current_each_item;\n\n\ttry {\n\t\tvar reactive = (flags & EACH_ITEM_REACTIVE) !== 0;\n\t\tvar mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;\n\n\t\tvar v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;\n\t\tvar i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);\n\n\t\t/** @type {EachItem} */\n\t\tvar item = {\n\t\t\ti,\n\t\t\tv,\n\t\t\tk: key,\n\t\t\ta: null,\n\t\t\t// @ts-expect-error\n\t\t\te: null,\n\t\t\tprev,\n\t\t\tnext\n\t\t};\n\n\t\tcurrent_each_item = item;\n\t\titem.e = branch(() => render_fn(anchor, v, i), hydrating);\n\n\t\titem.e.prev = prev && prev.e;\n\t\titem.e.next = next && next.e;\n\n\t\tif (prev === null) {\n\t\t\tstate.first = item;\n\t\t} else {\n\t\t\tprev.next = item;\n\t\t\tprev.e.next = item.e;\n\t\t}\n\n\t\tif (next !== null) {\n\t\t\tnext.prev = item;\n\t\t\tnext.e.prev = item.e;\n\t\t}\n\n\t\treturn item;\n\t} finally {\n\t\tcurrent_each_item = previous_each_item;\n\t}\n}\n\n/**\n * @param {EachItem} item\n * @param {EachItem | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(item, next, anchor) {\n\tvar end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;\n\n\tvar dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;\n\tvar node = /** @type {TemplateNode} */ (item.e.nodes_start);\n\n\twhile (node !== end) {\n\t\tvar next_node = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tdest.before(node);\n\t\tnode = next_node;\n\t}\n}\n\n/**\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n */\nfunction link(state, prev, next) {\n\tif (prev === null) {\n\t\tstate.first = next;\n\t} else {\n\t\tprev.next = next;\n\t\tprev.e.next = next && next.e;\n\t}\n\n\tif (next !== null) {\n\t\tnext.prev = prev;\n\t\tnext.e.prev = prev && prev.e;\n\t}\n}\n","/** @import { StoreReferencesContainer } from '#client' */\n/** @import { Store } from '#shared' */\nimport { subscribe_to_store } from '../../../store/utils.js';\nimport { noop } from '../../shared/utils.js';\nimport { get } from '../runtime.js';\nimport { teardown } from './effects.js';\nimport { mutable_source, set } from './sources.js';\n\n/**\n * Whether or not the prop currently being read is a store binding, as in\n * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in\n * runes mode, and skip `binding_property_non_reactive` validation\n */\nlet is_store_binding = false;\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\tconst entry = (stores[store_name] ??= {\n\t\tstore: null,\n\t\tsource: mutable_source(undefined),\n\t\tunsubscribe: noop\n\t});\n\n\tif (entry.store !== store) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\n\t\tif (store == null) {\n\t\t\tentry.source.v = undefined; // see synchronous callback comment below\n\t\t\tentry.unsubscribe = noop;\n\t\t} else {\n\t\t\tvar is_synchronous_callback = true;\n\n\t\t\tentry.unsubscribe = subscribe_to_store(store, (v) => {\n\t\t\t\tif (is_synchronous_callback) {\n\t\t\t\t\t// If the first updates to the store value (possibly multiple of them) are synchronously\n\t\t\t\t\t// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value\n\t\t\t\t\tentry.source.v = v;\n\t\t\t\t} else {\n\t\t\t\t\tset(entry.source, v);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tis_synchronous_callback = false;\n\t\t}\n\t}\n\n\treturn get(entry.source);\n}\n\n/**\n * Unsubscribe from a store if it's not the same as the one in the store references container.\n * We need this in addition to `store_get` because someone could unsubscribe from a store but\n * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully.\n * @param {Store<any> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n */\nexport function store_unsub(store, store_name, stores) {\n\t/** @type {StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\n\tif (entry && entry.store !== store) {\n\t\t// Don't reset store yet, so that store_get above can resubscribe to new store if necessary\n\t\tentry.unsubscribe();\n\t\tentry.unsubscribe = noop;\n\t}\n\n\treturn store;\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {StoreReferencesContainer} stores\n * @param {string} store_name\n */\nexport function invalidate_store(stores, store_name) {\n\tvar entry = stores[store_name];\n\tif (entry.store !== null) {\n\t\tstore_set(entry.store, entry.source.v);\n\t}\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @returns {StoreReferencesContainer}\n */\nexport function setup_stores() {\n\t/** @type {StoreReferencesContainer} */\n\tconst stores = {};\n\n\tteardown(() => {\n\t\tfor (var store_name in stores) {\n\t\t\tconst ref = stores[store_name];\n\t\t\tref.unsubscribe();\n\t\t}\n\t});\n\n\treturn stores;\n}\n\n/**\n * Updates a store with a new value.\n * @param {Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function store_mutate(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Called inside prop getters to communicate that the prop is a store binding\n */\nexport function mark_store_binding() {\n\tis_store_binding = true;\n}\n\n/**\n * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.\n * Used to prevent `binding_property_non_reactive` validation false positives and\n * ensure that these props are treated as mutable even in runes mode\n * @template T\n * @param {() => T} fn\n * @returns {[T, boolean]}\n */\nexport function capture_store_binding(fn) {\n\tvar previous_is_store_binding = is_store_binding;\n\n\ttry {\n\t\tis_store_binding = false;\n\t\treturn [fn(), is_store_binding];\n\t} finally {\n\t\tis_store_binding = previous_is_store_binding;\n\t}\n}\n","/** @import { Derived, Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { mutable_source, set, source } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tget,\n\tis_signals_recorded,\n\tset_active_effect,\n\tuntrack,\n\tupdate\n} from '../runtime.js';\nimport { safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { BRANCH_EFFECT, DESTROYED, LEGACY_DERIVED_PROP, ROOT_EFFECT } from '../constants.js';\nimport { proxy } from '../proxy.js';\nimport { capture_store_binding } from './store.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\ttarget.special[key] = prop(\n\t\t\t\t{\n\t\t\t\t\tget [key]() {\n\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/** @type {string} */ (key),\n\t\t\t\tPROPS_IS_UPDATED\n\t\t\t);\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tset(target, key, value) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tconst desc = get_descriptor(p, key);\n\t\t\tif (desc && desc.set) {\n\t\t\t\tdesc.set(value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nfunction with_parent_branch(fn) {\n\tvar effect = active_effect;\n\tvar previous_effect = active_effect;\n\n\twhile (effect !== null && (effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {\n\t\teffect = effect.parent;\n\t}\n\ttry {\n\t\tset_active_effect(effect);\n\t\treturn fn();\n\t} finally {\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\tvar is_store_sub = false;\n\tvar prop_value;\n\n\tif (bindable) {\n\t\t[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));\n\t} else {\n\t\tprop_value = /** @type {V} */ (props[key]);\n\t}\n\tvar setter = get_descriptor(props, key)?.set;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\tvar fallback_used = false;\n\n\tvar get_fallback = () => {\n\t\tfallback_used = true;\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\t\t\tif (lazy) {\n\t\t\t\tfallback_value = untrack(/** @type {() => V} */ (fallback));\n\t\t\t} else {\n\t\t\t\tfallback_value = /** @type {V} */ (fallback);\n\t\t\t}\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\tif (prop_value === undefined && fallback !== undefined) {\n\t\tif (setter && runes) {\n\t\t\te.props_invalid_value(key);\n\t\t}\n\n\t\tprop_value = get_fallback();\n\t\tif (setter) setter(prop_value);\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\tfallback_used = false;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\t\t// Replicate that behavior through using a derived\n\t\tvar derived_getter = with_parent_branch(() =>\n\t\t\t(immutable ? derived : derived_safe_equal)(() => /** @type {V} */ (props[key]))\n\t\t);\n\t\tderived_getter.f |= LEGACY_DERIVED_PROP;\n\t\tgetter = () => {\n\t\t\tvar value = get(derived_getter);\n\t\t\tif (value !== undefined) fallback_value = /** @type {V} */ (undefined);\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// easy mode — prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode — prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly — the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\n\tvar current_value = with_parent_branch(() =>\n\t\tderived(() => {\n\t\t\tvar parent_value = getter();\n\t\t\tvar child_value = get(inner_current_value);\n\t\t\tvar current_derived = /** @type {Derived} */ (active_reaction);\n\n\t\t\t// If the getter from the parent returns undefined, switch\n\t\t\t// to using the local value from inner_current_value instead,\n\t\t\t// as the parent value might have been torn down\n\t\t\tif (from_child || (parent_value === undefined && (current_derived.f & DESTROYED) !== 0)) {\n\t\t\t\tfrom_child = false;\n\t\t\t\twas_from_child = true;\n\t\t\t\treturn child_value;\n\t\t\t}\n\n\t\t\twas_from_child = false;\n\t\t\treturn (inner_current_value.v = parent_value);\n\t\t})\n\t);\n\n\tif (!immutable) current_value.equals = safe_equals;\n\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t// legacy nonsense — need to ensure the source is invalidated when necessary\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n\t\tif (is_signals_recorded) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tconst new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\n\n\t\t\tif (!current_value.equals(new_value)) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, new_value);\n\t\t\t\t// To ensure the fallback value is consistent when used with proxies, we\n\t\t\t\t// update the local fallback_value, but only if the fallback is actively used\n\t\t\t\tif (fallback_used && fallback_value !== undefined) {\n\t\t\t\t\tfallback_value = new_value;\n\t\t\t\t}\n\t\t\t\tuntrack(() => get(current_value)); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t\treturn get(current_value);\n\t};\n}\n"],"names":["current_each_item","index","_","i","pause_effects","state","items","controlled_anchor","items_map","transitions","length","pause_children","is_controlled","parent_node","clear_text_content","link","run_out_transitions","item","destroy_effect","each","node","flags","get_collection","get_key","render_fn","fallback_fn","anchor","EACH_IS_CONTROLLED","hydrating","set_hydrate_node","get_first_child","create_text","hydrate_next","fallback","was_empty","block","collection","array","is_array","array_from","mismatch","is_else","HYDRATION_START_ELSE","remove_nodes","set_hydrating","prev","hydrate_node","HYDRATION_END","value","key","create_item","reconcile","resume_effect","branch","pause_effect","is_animated","EACH_IS_ANIMATED","should_update","EACH_ITEM_REACTIVE","EACH_INDEX_REACTIVE","first","current","seen","to_animate","matched","stashed","_a","child_anchor","update_item","INERT","_b","start","j","a","b","move","to_destroy","destroy_length","_c","_d","queue_micro_task","active_effect","type","internal_set","next","previous_each_item","reactive","mutable","EACH_ITEM_IMMUTABLE","v","mutable_source","source","end","dest","next_node","get_next_sibling","is_store_binding","capture_store_binding","fn","previous_is_store_binding","spread_props_handler","target","p","is_function","desc","get_descriptor","descriptor","keys","spread_props","props","with_parent_branch","effect","previous_effect","BRANCH_EFFECT","ROOT_EFFECT","set_active_effect","prop","immutable","PROPS_IS_IMMUTABLE","runes","PROPS_IS_RUNES","bindable","PROPS_IS_BINDABLE","lazy","PROPS_IS_LAZY_INITIAL","is_store_sub","prop_value","setter","fallback_value","fallback_dirty","fallback_used","get_fallback","untrack","e.props_invalid_value","getter","derived_getter","derived","derived_safe_equal","LEGACY_DERIVED_PROP","get","PROPS_IS_UPDATED","legacy_parent","mutation","from_child","was_from_child","inner_current_value","current_value","parent_value","child_value","current_derived","active_reaction","DESTROYED","safe_equals","new_value","proxy","set"],"mappings":"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","x_google_ignoreList":[0,1,2]}