{"version":3,"file":"card.js","sources":["../../node_modules/svelte/src/internal/client/dom/blocks/each.js","../../node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js","../../node_modules/svelte/src/internal/client/reactivity/store.js","../../node_modules/svelte/src/internal/client/reactivity/props.js","../../src/blocks/card/Card.svelte","../../src/blocks/card/card.ts"],"sourcesContent":["/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */\nimport {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_ITEM_IMMUTABLE,\n\tEACH_ITEM_REACTIVE,\n\tHYDRATION_END,\n\tHYDRATION_START_ELSE\n} from '../../../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling\n} from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\trun_out_transitions,\n\tpause_children,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, internal_set } from '../../reactivity/sources.js';\nimport { array_from, is_array } from '../../../shared/utils.js';\nimport { INERT } from '../../constants.js';\nimport { queue_micro_task } from '../task.js';\nimport { active_effect } from '../../runtime.js';\n\n/**\n * The row of a keyed each block that is currently updating. We track this\n * so that `animate:` directives have something to attach themselves to\n * @type {EachItem | null}\n */\nexport let current_each_item = null;\n\n/** @param {EachItem | null} item */\nexport function set_current_each_item(item) {\n\tcurrent_each_item = item;\n}\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {EachState} state\n * @param {EachItem[]} items\n * @param {null | Node} controlled_anchor\n * @param {Map<any, EachItem>} items_map\n */\nfunction pause_effects(state, items, controlled_anchor, items_map) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = items.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tpause_children(items[i].e, transitions, true);\n\t}\n\n\tvar is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;\n\t// If we have a controlled anchor, it means that the each block is inside a single\n\t// DOM element, so we can apply a fast-path for clearing the contents of the element.\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (\n\t\t\t/** @type {Element} */ (controlled_anchor).parentNode\n\t\t);\n\t\tclear_text_content(parent_node);\n\t\tparent_node.append(/** @type {Element} */ (controlled_anchor));\n\t\titems_map.clear();\n\t\tlink(state, items[0].prev, items[length - 1].next);\n\t}\n\n\trun_out_transitions(transitions, () => {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar item = items[i];\n\t\t\tif (!is_controlled) {\n\t\t\t\titems_map.delete(item.k);\n\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t}\n\t\t\tdestroy_effect(item.e, !is_controlled);\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\tvar anchor = node;\n\n\t/** @type {EachState} */\n\tvar state = { flags, items: new Map(), first: null };\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (node);\n\n\t\tanchor = hydrating\n\t\t\t? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))\n\t\t\t: parent_node.appendChild(create_text());\n\t}\n\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\t/** @type {Effect | null} */\n\tvar fallback = null;\n\n\tvar was_empty = false;\n\n\tblock(() => {\n\t\tvar collection = get_collection();\n\n\t\tvar array = is_array(collection)\n\t\t\t? collection\n\t\t\t: collection == null\n\t\t\t\t? []\n\t\t\t\t: array_from(collection);\n\n\t\tvar length = array.length;\n\n\t\tif (was_empty && length === 0) {\n\t\t\t// ignore updates if the array is empty,\n\t\t\t// and it already was empty on previous run\n\t\t\treturn;\n\t\t}\n\t\twas_empty = length === 0;\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;\n\n\t\t\tif (is_else !== (length === 0)) {\n\t\t\t\t// hydration mismatch â€” remove the server-rendered DOM and start over\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\t// this is separate to the previous block because `hydrating` might change\n\t\tif (hydrating) {\n\t\t\t/** @type {EachItem | null} */\n\t\t\tvar prev = null;\n\n\t\t\t/** @type {EachItem} */\n\t\t\tvar item;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tif (\n\t\t\t\t\thydrate_node.nodeType === 8 &&\n\t\t\t\t\t/** @type {Comment} */ (hydrate_node).data === HYDRATION_END\n\t\t\t\t) {\n\t\t\t\t\t// The server rendered fewer items than expected,\n\t\t\t\t\t// so break out and continue appending non-hydrated items\n\t\t\t\t\tanchor = /** @type {Comment} */ (hydrate_node);\n\t\t\t\t\tmismatch = true;\n\t\t\t\t\tset_hydrating(false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvar value = array[i];\n\t\t\t\tvar key = get_key(value, i);\n\t\t\t\titem = create_item(hydrate_node, state, prev, null, value, key, i, render_fn, flags);\n\t\t\t\tstate.items.set(key, item);\n\n\t\t\t\tprev = item;\n\t\t\t}\n\n\t\t\t// remove excess nodes\n\t\t\tif (length > 0) {\n\t\t\t\tset_hydrate_node(remove_nodes());\n\t\t\t}\n\t\t}\n\n\t\tif (!hydrating) {\n\t\t\treconcile(array, state, anchor, render_fn, flags, get_key);\n\t\t}\n\n\t\tif (fallback_fn !== null) {\n\t\t\tif (length === 0) {\n\t\t\t\tif (fallback) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t\t}\n\t\t\t} else if (fallback !== null) {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// When we mount the each block for the first time, the collection won't be\n\t\t// connected to this effect as the effect hasn't finished running yet and its deps\n\t\t// won't be assigned. However, it's possible that when reconciling the each block\n\t\t// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the\n\t\t// collection again can provide consistency to the reactive graph again as the deriveds\n\t\t// will now be `CLEAN`.\n\t\tget_collection();\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * Add, remove, or reorder items output by an each block as its input changes\n * @template V\n * @param {Array<V>} array\n * @param {EachState} state\n * @param {Element | Comment | Text} anchor\n * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>) => void} render_fn\n * @param {number} flags\n * @param {(value: V, index: number) => any} get_key\n * @returns {void}\n */\nfunction reconcile(array, state, anchor, render_fn, flags, get_key) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\tvar should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar first = state.first;\n\tvar current = first;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar seen;\n\n\t/** @type {EachItem | null} */\n\tvar prev = null;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar to_animate;\n\n\t/** @type {EachItem[]} */\n\tvar matched = [];\n\n\t/** @type {EachItem[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {EachItem | undefined} */\n\tvar item;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\titem = items.get(key);\n\n\t\t\tif (item !== undefined) {\n\t\t\t\titem.a?.measure();\n\t\t\t\t(to_animate ??= new Set()).add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\t\titem = items.get(key);\n\n\t\tif (item === undefined) {\n\t\t\tvar child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;\n\n\t\t\tprev = create_item(\n\t\t\t\tchild_anchor,\n\t\t\t\tstate,\n\t\t\t\tprev,\n\t\t\t\tprev === null ? state.first : prev.next,\n\t\t\t\tvalue,\n\t\t\t\tkey,\n\t\t\t\ti,\n\t\t\t\trender_fn,\n\t\t\t\tflags\n\t\t\t);\n\n\t\t\titems.set(key, prev);\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\tcurrent = prev.next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (should_update) {\n\t\t\tupdate_item(item, value, i, flags);\n\t\t}\n\n\t\tif ((item.e.f & INERT) !== 0) {\n\t\t\tresume_effect(item.e);\n\t\t\tif (is_animated) {\n\t\t\t\titem.a?.unfix();\n\t\t\t\t(to_animate ??= new Set()).delete(item);\n\t\t\t}\n\t\t}\n\n\t\tif (item !== current) {\n\t\t\tif (seen !== undefined && seen.has(item)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(state, a.prev, b.next);\n\t\t\t\t\tlink(state, prev, a);\n\t\t\t\t\tlink(state, b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(item);\n\t\t\t\t\tmove(item, current, anchor);\n\n\t\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t\t\tlink(state, item, prev === null ? state.first : prev.next);\n\t\t\t\t\tlink(state, prev, item);\n\n\t\t\t\t\tprev = item;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current.k !== key) {\n\t\t\t\t// If the item has an effect that is already inert, skip over adding it\n\t\t\t\t// to our seen Set as the item is already being handled\n\t\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\t\t(seen ??= new Set()).add(current);\n\t\t\t\t}\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titem = current;\n\t\t}\n\n\t\tmatched.push(item);\n\t\tprev = item;\n\t\tcurrent = item.next;\n\t}\n\n\tif (current !== null || seen !== undefined) {\n\t\tvar to_destroy = seen === undefined ? [] : array_from(seen);\n\n\t\twhile (current !== null) {\n\t\t\t// Inert effects are currently outroing and will be removed once the transition is finished\n\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\tto_destroy.push(current);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\n\t\tvar destroy_length = to_destroy.length;\n\n\t\tif (destroy_length > 0) {\n\t\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\t\tif (is_animated) {\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.measure();\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.fix();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpause_effects(state, to_destroy, controlled_anchor, items);\n\t\t}\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (to_animate === undefined) return;\n\t\t\tfor (item of to_animate) {\n\t\t\t\titem.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n\n\t/** @type {Effect} */ (active_effect).first = state.first && state.first.e;\n\t/** @type {Effect} */ (active_effect).last = prev && prev.e;\n}\n\n/**\n * @param {EachItem} item\n * @param {any} value\n * @param {number} index\n * @param {number} type\n * @returns {void}\n */\nfunction update_item(item, value, index, type) {\n\tif ((type & EACH_ITEM_REACTIVE) !== 0) {\n\t\tinternal_set(item.v, value);\n\t}\n\n\tif ((type & EACH_INDEX_REACTIVE) !== 0) {\n\t\tinternal_set(/** @type {Value<number>} */ (item.i), index);\n\t} else {\n\t\titem.i = index;\n\t}\n}\n\n/**\n * @template V\n * @param {Node} anchor\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>) => void} render_fn\n * @param {number} flags\n * @returns {EachItem}\n */\nfunction create_item(anchor, state, prev, next, value, key, index, render_fn, flags) {\n\tvar previous_each_item = current_each_item;\n\n\ttry {\n\t\tvar reactive = (flags & EACH_ITEM_REACTIVE) !== 0;\n\t\tvar mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;\n\n\t\tvar v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;\n\t\tvar i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);\n\n\t\t/** @type {EachItem} */\n\t\tvar item = {\n\t\t\ti,\n\t\t\tv,\n\t\t\tk: key,\n\t\t\ta: null,\n\t\t\t// @ts-expect-error\n\t\t\te: null,\n\t\t\tprev,\n\t\t\tnext\n\t\t};\n\n\t\tcurrent_each_item = item;\n\t\titem.e = branch(() => render_fn(anchor, v, i), hydrating);\n\n\t\titem.e.prev = prev && prev.e;\n\t\titem.e.next = next && next.e;\n\n\t\tif (prev === null) {\n\t\t\tstate.first = item;\n\t\t} else {\n\t\t\tprev.next = item;\n\t\t\tprev.e.next = item.e;\n\t\t}\n\n\t\tif (next !== null) {\n\t\t\tnext.prev = item;\n\t\t\tnext.e.prev = item.e;\n\t\t}\n\n\t\treturn item;\n\t} finally {\n\t\tcurrent_each_item = previous_each_item;\n\t}\n}\n\n/**\n * @param {EachItem} item\n * @param {EachItem | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(item, next, anchor) {\n\tvar end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;\n\n\tvar dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;\n\tvar node = /** @type {TemplateNode} */ (item.e.nodes_start);\n\n\twhile (node !== end) {\n\t\tvar next_node = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tdest.before(node);\n\t\tnode = next_node;\n\t}\n}\n\n/**\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n */\nfunction link(state, prev, next) {\n\tif (prev === null) {\n\t\tstate.first = next;\n\t} else {\n\t\tprev.next = next;\n\t\tprev.e.next = next && next.e;\n\t}\n\n\tif (next !== null) {\n\t\tnext.prev = prev;\n\t\tnext.e.prev = prev && prev.e;\n\t}\n}\n","/** @import { ComponentContextLegacy } from '#client' */\nimport { run, run_all } from '../../../shared/utils.js';\nimport { derived } from '../../reactivity/deriveds.js';\nimport { user_pre_effect, user_effect } from '../../reactivity/effects.js';\nimport { component_context, deep_read_state, get, untrack } from '../../runtime.js';\n\n/**\n * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects\n * @param {boolean} [immutable]\n */\nexport function init(immutable = false) {\n\tconst context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\tconst callbacks = context.l.u;\n\tif (!callbacks) return;\n\n\tlet props = () => deep_read_state(context.s);\n\n\tif (immutable) {\n\t\tlet version = 0;\n\t\tlet prev = /** @type {Record<string, any>} */ ({});\n\n\t\t// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes\n\t\tconst d = derived(() => {\n\t\t\tlet changed = false;\n\t\t\tconst props = context.s;\n\t\t\tfor (const key in props) {\n\t\t\t\tif (props[key] !== prev[key]) {\n\t\t\t\t\tprev[key] = props[key];\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (changed) version++;\n\t\t\treturn version;\n\t\t});\n\n\t\tprops = () => get(d);\n\t}\n\n\t// beforeUpdate\n\tif (callbacks.b.length) {\n\t\tuser_pre_effect(() => {\n\t\t\tobserve_all(context, props);\n\t\t\trun_all(callbacks.b);\n\t\t});\n\t}\n\n\t// onMount (must run before afterUpdate)\n\tuser_effect(() => {\n\t\tconst fns = untrack(() => callbacks.m.map(run));\n\t\treturn () => {\n\t\t\tfor (const fn of fns) {\n\t\t\t\tif (typeof fn === 'function') {\n\t\t\t\t\tfn();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n\n\t// afterUpdate\n\tif (callbacks.a.length) {\n\t\tuser_effect(() => {\n\t\t\tobserve_all(context, props);\n\t\t\trun_all(callbacks.a);\n\t\t});\n\t}\n}\n\n/**\n * Invoke the getter of all signals associated with a component\n * so they can be registered to the effect this function is called in.\n * @param {ComponentContextLegacy} context\n * @param {(() => void)} props\n */\nfunction observe_all(context, props) {\n\tif (context.l.s) {\n\t\tfor (const signal of context.l.s) get(signal);\n\t}\n\n\tprops();\n}\n","/** @import { StoreReferencesContainer } from '#client' */\n/** @import { Store } from '#shared' */\nimport { subscribe_to_store } from '../../../store/utils.js';\nimport { noop } from '../../shared/utils.js';\nimport { get } from '../runtime.js';\nimport { teardown } from './effects.js';\nimport { mutable_source, set } from './sources.js';\n\n/**\n * Whether or not the prop currently being read is a store binding, as in\n * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in\n * runes mode, and skip `binding_property_non_reactive` validation\n */\nlet is_store_binding = false;\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\tconst entry = (stores[store_name] ??= {\n\t\tstore: null,\n\t\tsource: mutable_source(undefined),\n\t\tunsubscribe: noop\n\t});\n\n\tif (entry.store !== store) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\n\t\tif (store == null) {\n\t\t\tentry.source.v = undefined; // see synchronous callback comment below\n\t\t\tentry.unsubscribe = noop;\n\t\t} else {\n\t\t\tvar is_synchronous_callback = true;\n\n\t\t\tentry.unsubscribe = subscribe_to_store(store, (v) => {\n\t\t\t\tif (is_synchronous_callback) {\n\t\t\t\t\t// If the first updates to the store value (possibly multiple of them) are synchronously\n\t\t\t\t\t// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value\n\t\t\t\t\tentry.source.v = v;\n\t\t\t\t} else {\n\t\t\t\t\tset(entry.source, v);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tis_synchronous_callback = false;\n\t\t}\n\t}\n\n\treturn get(entry.source);\n}\n\n/**\n * Unsubscribe from a store if it's not the same as the one in the store references container.\n * We need this in addition to `store_get` because someone could unsubscribe from a store but\n * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully.\n * @param {Store<any> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n */\nexport function store_unsub(store, store_name, stores) {\n\t/** @type {StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\n\tif (entry && entry.store !== store) {\n\t\t// Don't reset store yet, so that store_get above can resubscribe to new store if necessary\n\t\tentry.unsubscribe();\n\t\tentry.unsubscribe = noop;\n\t}\n\n\treturn store;\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {StoreReferencesContainer} stores\n * @param {string} store_name\n */\nexport function invalidate_store(stores, store_name) {\n\tvar entry = stores[store_name];\n\tif (entry.store !== null) {\n\t\tstore_set(entry.store, entry.source.v);\n\t}\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @returns {StoreReferencesContainer}\n */\nexport function setup_stores() {\n\t/** @type {StoreReferencesContainer} */\n\tconst stores = {};\n\n\tteardown(() => {\n\t\tfor (var store_name in stores) {\n\t\t\tconst ref = stores[store_name];\n\t\t\tref.unsubscribe();\n\t\t}\n\t});\n\n\treturn stores;\n}\n\n/**\n * Updates a store with a new value.\n * @param {Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function store_mutate(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Called inside prop getters to communicate that the prop is a store binding\n */\nexport function mark_store_binding() {\n\tis_store_binding = true;\n}\n\n/**\n * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.\n * Used to prevent `binding_property_non_reactive` validation false positives and\n * ensure that these props are treated as mutable even in runes mode\n * @template T\n * @param {() => T} fn\n * @returns {[T, boolean]}\n */\nexport function capture_store_binding(fn) {\n\tvar previous_is_store_binding = is_store_binding;\n\n\ttry {\n\t\tis_store_binding = false;\n\t\treturn [fn(), is_store_binding];\n\t} finally {\n\t\tis_store_binding = previous_is_store_binding;\n\t}\n}\n","/** @import { Derived, Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { mutable_source, set, source } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tget,\n\tis_signals_recorded,\n\tset_active_effect,\n\tuntrack,\n\tupdate\n} from '../runtime.js';\nimport { safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { BRANCH_EFFECT, DESTROYED, LEGACY_DERIVED_PROP, ROOT_EFFECT } from '../constants.js';\nimport { proxy } from '../proxy.js';\nimport { capture_store_binding } from './store.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\ttarget.special[key] = prop(\n\t\t\t\t{\n\t\t\t\t\tget [key]() {\n\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/** @type {string} */ (key),\n\t\t\t\tPROPS_IS_UPDATED\n\t\t\t);\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tset(target, key, value) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tconst desc = get_descriptor(p, key);\n\t\t\tif (desc && desc.set) {\n\t\t\t\tdesc.set(value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nfunction with_parent_branch(fn) {\n\tvar effect = active_effect;\n\tvar previous_effect = active_effect;\n\n\twhile (effect !== null && (effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {\n\t\teffect = effect.parent;\n\t}\n\ttry {\n\t\tset_active_effect(effect);\n\t\treturn fn();\n\t} finally {\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\tvar is_store_sub = false;\n\tvar prop_value;\n\n\tif (bindable) {\n\t\t[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));\n\t} else {\n\t\tprop_value = /** @type {V} */ (props[key]);\n\t}\n\tvar setter = get_descriptor(props, key)?.set;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\tvar fallback_used = false;\n\n\tvar get_fallback = () => {\n\t\tfallback_used = true;\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\t\t\tif (lazy) {\n\t\t\t\tfallback_value = untrack(/** @type {() => V} */ (fallback));\n\t\t\t} else {\n\t\t\t\tfallback_value = /** @type {V} */ (fallback);\n\t\t\t}\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\tif (prop_value === undefined && fallback !== undefined) {\n\t\tif (setter && runes) {\n\t\t\te.props_invalid_value(key);\n\t\t}\n\n\t\tprop_value = get_fallback();\n\t\tif (setter) setter(prop_value);\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\tfallback_used = false;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\t\t// Replicate that behavior through using a derived\n\t\tvar derived_getter = with_parent_branch(() =>\n\t\t\t(immutable ? derived : derived_safe_equal)(() => /** @type {V} */ (props[key]))\n\t\t);\n\t\tderived_getter.f |= LEGACY_DERIVED_PROP;\n\t\tgetter = () => {\n\t\t\tvar value = get(derived_getter);\n\t\t\tif (value !== undefined) fallback_value = /** @type {V} */ (undefined);\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// easy mode â€” prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode â€” prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly â€” the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\n\tvar current_value = with_parent_branch(() =>\n\t\tderived(() => {\n\t\t\tvar parent_value = getter();\n\t\t\tvar child_value = get(inner_current_value);\n\t\t\tvar current_derived = /** @type {Derived} */ (active_reaction);\n\n\t\t\t// If the getter from the parent returns undefined, switch\n\t\t\t// to using the local value from inner_current_value instead,\n\t\t\t// as the parent value might have been torn down\n\t\t\tif (from_child || (parent_value === undefined && (current_derived.f & DESTROYED) !== 0)) {\n\t\t\t\tfrom_child = false;\n\t\t\t\twas_from_child = true;\n\t\t\t\treturn child_value;\n\t\t\t}\n\n\t\t\twas_from_child = false;\n\t\t\treturn (inner_current_value.v = parent_value);\n\t\t})\n\t);\n\n\tif (!immutable) current_value.equals = safe_equals;\n\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t// legacy nonsense â€” need to ensure the source is invalidated when necessary\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n\t\tif (is_signals_recorded) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tconst new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\n\n\t\t\tif (!current_value.equals(new_value)) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, new_value);\n\t\t\t\t// To ensure the fallback value is consistent when used with proxies, we\n\t\t\t\t// update the local fallback_value, but only if the fallback is actively used\n\t\t\t\tif (fallback_used && fallback_value !== undefined) {\n\t\t\t\t\tfallback_value = new_value;\n\t\t\t\t}\n\t\t\t\tuntrack(() => get(current_value)); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t\treturn get(current_value);\n\t};\n}\n","<script>\n    export let block;\n\n    // This function creates an optimized picture object\n    function createOptimizedPicture(src, alt, flag, sizes) {\n        return { src, alt, sizes };\n    }\n\n    // Helper function to determine the class name based on the content\n    function getClass(div) {\n        if (div.children.length === 1 && div.querySelector('picture')) {\n            return 'cards-card-image';\n        }\n        return 'cards-card-body';\n    }\n</script>\n\n<ul>\n    {#each block.children as row (row)}\n        <li>\n            {#each row.children as div (div)}\n                <div class={getClass(div)}>\n                    {#if div.querySelector('picture')}\n                        {#each Array.from(div.querySelectorAll('picture > img')) as img (img)}\n                            <picture>\n                                <img src={img.src} alt={img.alt} />\n                            </picture>\n                        {/each}\n                    {:else}\n                        {@html div.innerHTML}\n                    {/if}\n                </div>\n            {/each}\n        </li>\n    {/each}\n</ul>","import Card from './Card.svelte';\n\nexport default async function decorate(block) {\n    new Card({\n        target: block,\n    })\n}\n"],"names":["current_each_item","pause_effects","state","items","controlled_anchor","items_map","transitions","length","i","pause_children","is_controlled","parent_node","clear_text_content","link","run_out_transitions","item","destroy_effect","each","node","flags","get_collection","get_key","render_fn","fallback_fn","anchor","EACH_IS_CONTROLLED","hydrating","set_hydrate_node","get_first_child","create_text","hydrate_next","fallback","was_empty","block","collection","array","is_array","array_from","mismatch","is_else","HYDRATION_START_ELSE","remove_nodes","set_hydrating","prev","hydrate_node","HYDRATION_END","value","key","create_item","reconcile","resume_effect","branch","pause_effect","is_animated","EACH_IS_ANIMATED","should_update","EACH_ITEM_REACTIVE","EACH_INDEX_REACTIVE","first","current","seen","to_animate","matched","stashed","_a","child_anchor","update_item","INERT","_b","start","j","a","b","move","to_destroy","destroy_length","_c","_d","queue_micro_task","active_effect","index","type","internal_set","next","previous_each_item","reactive","mutable","EACH_ITEM_IMMUTABLE","v","mutable_source","source","end","dest","next_node","get_next_sibling","init","immutable","context","component_context","callbacks","props","deep_read_state","version","d","derived","changed","get","user_pre_effect","observe_all","run_all","user_effect","fns","untrack","run","fn","signal","is_store_binding","capture_store_binding","previous_is_store_binding","with_parent_branch","effect","previous_effect","BRANCH_EFFECT","ROOT_EFFECT","set_active_effect","prop","PROPS_IS_IMMUTABLE","runes","PROPS_IS_RUNES","is_store_sub","prop_value","setter","get_descriptor","fallback_value","fallback_dirty","get_fallback","e.props_invalid_value","getter","derived_getter","derived_safe_equal","LEGACY_DERIVED_PROP","$.prop","$$props","getClass","div","$.each","ul","row","li","$.get","class_derived","$.derived_safe_equal","node_1","img","$.set_attribute","img_1","$.html","node_2","decorate","Card"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}