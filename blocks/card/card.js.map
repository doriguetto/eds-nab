{"version":3,"file":"card.js","sources":["../../node_modules/svelte/src/internal/client/dom/task.js","../../node_modules/svelte/src/internal/client/dom/blocks/if.js","../../node_modules/svelte/src/internal/client/dom/blocks/each.js","../../node_modules/svelte/src/internal/client/dom/elements/class.js","../../node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js","../../node_modules/svelte/src/internal/client/reactivity/store.js","../../node_modules/svelte/src/internal/client/reactivity/props.js","../../src/blocks/card/Card.svelte","../../src/blocks/card/card.ts"],"sourcesContent":["import { run_all } from '../../shared/utils.js';\n\n// Fallback for when requestIdleCallback is not available\nconst request_idle_callback =\n\ttypeof requestIdleCallback === 'undefined'\n\t\t? (/** @type {() => void} */ cb) => setTimeout(cb, 1)\n\t\t: requestIdleCallback;\n\nlet is_micro_task_queued = false;\nlet is_idle_task_queued = false;\n\n/** @type {Array<() => void>} */\nlet current_queued_micro_tasks = [];\n/** @type {Array<() => void>} */\nlet current_queued_idle_tasks = [];\n\nfunction process_micro_tasks() {\n\tis_micro_task_queued = false;\n\tconst tasks = current_queued_micro_tasks.slice();\n\tcurrent_queued_micro_tasks = [];\n\trun_all(tasks);\n}\n\nfunction process_idle_tasks() {\n\tis_idle_task_queued = false;\n\tconst tasks = current_queued_idle_tasks.slice();\n\tcurrent_queued_idle_tasks = [];\n\trun_all(tasks);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_micro_task(fn) {\n\tif (!is_micro_task_queued) {\n\t\tis_micro_task_queued = true;\n\t\tqueueMicrotask(process_micro_tasks);\n\t}\n\tcurrent_queued_micro_tasks.push(fn);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_idle_task(fn) {\n\tif (!is_idle_task_queued) {\n\t\tis_idle_task_queued = true;\n\t\trequest_idle_callback(process_idle_tasks);\n\t}\n\tcurrent_queued_idle_tasks.push(fn);\n}\n\n/**\n * Synchronously run any queued tasks.\n */\nexport function flush_tasks() {\n\tif (is_micro_task_queued) {\n\t\tprocess_micro_tasks();\n\t}\n\tif (is_idle_task_queued) {\n\t\tprocess_idle_tasks();\n\t}\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_START_ELSE } from '../../../../constants.js';\n\n/**\n * @param {TemplateNode} node\n * @param {() => boolean} get_condition\n * @param {(anchor: Node) => void} consequent_fn\n * @param {null | ((anchor: Node) => void)} [alternate_fn]\n * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'\n * @returns {void}\n */\nexport function if_block(node, get_condition, consequent_fn, alternate_fn = null, elseif = false) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {boolean | null} */\n\tvar condition = null;\n\n\tvar flags = elseif ? EFFECT_TRANSPARENT : 0;\n\n\tblock(() => {\n\t\tif (condition === (condition = !!get_condition())) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tconst is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;\n\n\t\t\tif (condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\tif (condition) {\n\t\t\tif (consequent_effect) {\n\t\t\t\tresume_effect(consequent_effect);\n\t\t\t} else {\n\t\t\t\tconsequent_effect = branch(() => consequent_fn(anchor));\n\t\t\t}\n\n\t\t\tif (alternate_effect) {\n\t\t\t\tpause_effect(alternate_effect, () => {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (alternate_effect) {\n\t\t\t\tresume_effect(alternate_effect);\n\t\t\t} else if (alternate_fn) {\n\t\t\t\talternate_effect = branch(() => alternate_fn(anchor));\n\t\t\t}\n\n\t\t\tif (consequent_effect) {\n\t\t\t\tpause_effect(consequent_effect, () => {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t}, flags);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */\nimport {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_ITEM_IMMUTABLE,\n\tEACH_ITEM_REACTIVE,\n\tHYDRATION_END,\n\tHYDRATION_START_ELSE\n} from '../../../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling\n} from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\trun_out_transitions,\n\tpause_children,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, internal_set } from '../../reactivity/sources.js';\nimport { array_from, is_array } from '../../../shared/utils.js';\nimport { INERT } from '../../constants.js';\nimport { queue_micro_task } from '../task.js';\nimport { active_effect } from '../../runtime.js';\n\n/**\n * The row of a keyed each block that is currently updating. We track this\n * so that `animate:` directives have something to attach themselves to\n * @type {EachItem | null}\n */\nexport let current_each_item = null;\n\n/** @param {EachItem | null} item */\nexport function set_current_each_item(item) {\n\tcurrent_each_item = item;\n}\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {EachState} state\n * @param {EachItem[]} items\n * @param {null | Node} controlled_anchor\n * @param {Map<any, EachItem>} items_map\n */\nfunction pause_effects(state, items, controlled_anchor, items_map) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = items.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tpause_children(items[i].e, transitions, true);\n\t}\n\n\tvar is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;\n\t// If we have a controlled anchor, it means that the each block is inside a single\n\t// DOM element, so we can apply a fast-path for clearing the contents of the element.\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (\n\t\t\t/** @type {Element} */ (controlled_anchor).parentNode\n\t\t);\n\t\tclear_text_content(parent_node);\n\t\tparent_node.append(/** @type {Element} */ (controlled_anchor));\n\t\titems_map.clear();\n\t\tlink(state, items[0].prev, items[length - 1].next);\n\t}\n\n\trun_out_transitions(transitions, () => {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar item = items[i];\n\t\t\tif (!is_controlled) {\n\t\t\t\titems_map.delete(item.k);\n\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t}\n\t\t\tdestroy_effect(item.e, !is_controlled);\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\tvar anchor = node;\n\n\t/** @type {EachState} */\n\tvar state = { flags, items: new Map(), first: null };\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (node);\n\n\t\tanchor = hydrating\n\t\t\t? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))\n\t\t\t: parent_node.appendChild(create_text());\n\t}\n\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\t/** @type {Effect | null} */\n\tvar fallback = null;\n\n\tvar was_empty = false;\n\n\tblock(() => {\n\t\tvar collection = get_collection();\n\n\t\tvar array = is_array(collection)\n\t\t\t? collection\n\t\t\t: collection == null\n\t\t\t\t? []\n\t\t\t\t: array_from(collection);\n\n\t\tvar length = array.length;\n\n\t\tif (was_empty && length === 0) {\n\t\t\t// ignore updates if the array is empty,\n\t\t\t// and it already was empty on previous run\n\t\t\treturn;\n\t\t}\n\t\twas_empty = length === 0;\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;\n\n\t\t\tif (is_else !== (length === 0)) {\n\t\t\t\t// hydration mismatch — remove the server-rendered DOM and start over\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\t// this is separate to the previous block because `hydrating` might change\n\t\tif (hydrating) {\n\t\t\t/** @type {EachItem | null} */\n\t\t\tvar prev = null;\n\n\t\t\t/** @type {EachItem} */\n\t\t\tvar item;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tif (\n\t\t\t\t\thydrate_node.nodeType === 8 &&\n\t\t\t\t\t/** @type {Comment} */ (hydrate_node).data === HYDRATION_END\n\t\t\t\t) {\n\t\t\t\t\t// The server rendered fewer items than expected,\n\t\t\t\t\t// so break out and continue appending non-hydrated items\n\t\t\t\t\tanchor = /** @type {Comment} */ (hydrate_node);\n\t\t\t\t\tmismatch = true;\n\t\t\t\t\tset_hydrating(false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvar value = array[i];\n\t\t\t\tvar key = get_key(value, i);\n\t\t\t\titem = create_item(hydrate_node, state, prev, null, value, key, i, render_fn, flags);\n\t\t\t\tstate.items.set(key, item);\n\n\t\t\t\tprev = item;\n\t\t\t}\n\n\t\t\t// remove excess nodes\n\t\t\tif (length > 0) {\n\t\t\t\tset_hydrate_node(remove_nodes());\n\t\t\t}\n\t\t}\n\n\t\tif (!hydrating) {\n\t\t\treconcile(array, state, anchor, render_fn, flags, get_key);\n\t\t}\n\n\t\tif (fallback_fn !== null) {\n\t\t\tif (length === 0) {\n\t\t\t\tif (fallback) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t\t}\n\t\t\t} else if (fallback !== null) {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// When we mount the each block for the first time, the collection won't be\n\t\t// connected to this effect as the effect hasn't finished running yet and its deps\n\t\t// won't be assigned. However, it's possible that when reconciling the each block\n\t\t// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the\n\t\t// collection again can provide consistency to the reactive graph again as the deriveds\n\t\t// will now be `CLEAN`.\n\t\tget_collection();\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * Add, remove, or reorder items output by an each block as its input changes\n * @template V\n * @param {Array<V>} array\n * @param {EachState} state\n * @param {Element | Comment | Text} anchor\n * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>) => void} render_fn\n * @param {number} flags\n * @param {(value: V, index: number) => any} get_key\n * @returns {void}\n */\nfunction reconcile(array, state, anchor, render_fn, flags, get_key) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\tvar should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar first = state.first;\n\tvar current = first;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar seen;\n\n\t/** @type {EachItem | null} */\n\tvar prev = null;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar to_animate;\n\n\t/** @type {EachItem[]} */\n\tvar matched = [];\n\n\t/** @type {EachItem[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {EachItem | undefined} */\n\tvar item;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\titem = items.get(key);\n\n\t\t\tif (item !== undefined) {\n\t\t\t\titem.a?.measure();\n\t\t\t\t(to_animate ??= new Set()).add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\t\titem = items.get(key);\n\n\t\tif (item === undefined) {\n\t\t\tvar child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;\n\n\t\t\tprev = create_item(\n\t\t\t\tchild_anchor,\n\t\t\t\tstate,\n\t\t\t\tprev,\n\t\t\t\tprev === null ? state.first : prev.next,\n\t\t\t\tvalue,\n\t\t\t\tkey,\n\t\t\t\ti,\n\t\t\t\trender_fn,\n\t\t\t\tflags\n\t\t\t);\n\n\t\t\titems.set(key, prev);\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\tcurrent = prev.next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (should_update) {\n\t\t\tupdate_item(item, value, i, flags);\n\t\t}\n\n\t\tif ((item.e.f & INERT) !== 0) {\n\t\t\tresume_effect(item.e);\n\t\t\tif (is_animated) {\n\t\t\t\titem.a?.unfix();\n\t\t\t\t(to_animate ??= new Set()).delete(item);\n\t\t\t}\n\t\t}\n\n\t\tif (item !== current) {\n\t\t\tif (seen !== undefined && seen.has(item)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(state, a.prev, b.next);\n\t\t\t\t\tlink(state, prev, a);\n\t\t\t\t\tlink(state, b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(item);\n\t\t\t\t\tmove(item, current, anchor);\n\n\t\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t\t\tlink(state, item, prev === null ? state.first : prev.next);\n\t\t\t\t\tlink(state, prev, item);\n\n\t\t\t\t\tprev = item;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current.k !== key) {\n\t\t\t\t// If the item has an effect that is already inert, skip over adding it\n\t\t\t\t// to our seen Set as the item is already being handled\n\t\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\t\t(seen ??= new Set()).add(current);\n\t\t\t\t}\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titem = current;\n\t\t}\n\n\t\tmatched.push(item);\n\t\tprev = item;\n\t\tcurrent = item.next;\n\t}\n\n\tif (current !== null || seen !== undefined) {\n\t\tvar to_destroy = seen === undefined ? [] : array_from(seen);\n\n\t\twhile (current !== null) {\n\t\t\t// Inert effects are currently outroing and will be removed once the transition is finished\n\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\tto_destroy.push(current);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\n\t\tvar destroy_length = to_destroy.length;\n\n\t\tif (destroy_length > 0) {\n\t\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\t\tif (is_animated) {\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.measure();\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.fix();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpause_effects(state, to_destroy, controlled_anchor, items);\n\t\t}\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (to_animate === undefined) return;\n\t\t\tfor (item of to_animate) {\n\t\t\t\titem.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n\n\t/** @type {Effect} */ (active_effect).first = state.first && state.first.e;\n\t/** @type {Effect} */ (active_effect).last = prev && prev.e;\n}\n\n/**\n * @param {EachItem} item\n * @param {any} value\n * @param {number} index\n * @param {number} type\n * @returns {void}\n */\nfunction update_item(item, value, index, type) {\n\tif ((type & EACH_ITEM_REACTIVE) !== 0) {\n\t\tinternal_set(item.v, value);\n\t}\n\n\tif ((type & EACH_INDEX_REACTIVE) !== 0) {\n\t\tinternal_set(/** @type {Value<number>} */ (item.i), index);\n\t} else {\n\t\titem.i = index;\n\t}\n}\n\n/**\n * @template V\n * @param {Node} anchor\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>) => void} render_fn\n * @param {number} flags\n * @returns {EachItem}\n */\nfunction create_item(anchor, state, prev, next, value, key, index, render_fn, flags) {\n\tvar previous_each_item = current_each_item;\n\n\ttry {\n\t\tvar reactive = (flags & EACH_ITEM_REACTIVE) !== 0;\n\t\tvar mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;\n\n\t\tvar v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;\n\t\tvar i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);\n\n\t\t/** @type {EachItem} */\n\t\tvar item = {\n\t\t\ti,\n\t\t\tv,\n\t\t\tk: key,\n\t\t\ta: null,\n\t\t\t// @ts-expect-error\n\t\t\te: null,\n\t\t\tprev,\n\t\t\tnext\n\t\t};\n\n\t\tcurrent_each_item = item;\n\t\titem.e = branch(() => render_fn(anchor, v, i), hydrating);\n\n\t\titem.e.prev = prev && prev.e;\n\t\titem.e.next = next && next.e;\n\n\t\tif (prev === null) {\n\t\t\tstate.first = item;\n\t\t} else {\n\t\t\tprev.next = item;\n\t\t\tprev.e.next = item.e;\n\t\t}\n\n\t\tif (next !== null) {\n\t\t\tnext.prev = item;\n\t\t\tnext.e.prev = item.e;\n\t\t}\n\n\t\treturn item;\n\t} finally {\n\t\tcurrent_each_item = previous_each_item;\n\t}\n}\n\n/**\n * @param {EachItem} item\n * @param {EachItem | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(item, next, anchor) {\n\tvar end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;\n\n\tvar dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;\n\tvar node = /** @type {TemplateNode} */ (item.e.nodes_start);\n\n\twhile (node !== end) {\n\t\tvar next_node = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tdest.before(node);\n\t\tnode = next_node;\n\t}\n}\n\n/**\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n */\nfunction link(state, prev, next) {\n\tif (prev === null) {\n\t\tstate.first = next;\n\t} else {\n\t\tprev.next = next;\n\t\tprev.e.next = next && next.e;\n\t}\n\n\tif (next !== null) {\n\t\tnext.prev = prev;\n\t\tnext.e.prev = prev && prev.e;\n\t}\n}\n","import { hydrating } from '../hydration.js';\n\n/**\n * @param {SVGElement} dom\n * @param {string} value\n * @returns {void}\n */\nexport function set_svg_class(dom, value) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev_class_name = dom.__className;\n\tvar next_class_name = to_class(value);\n\n\tif (hydrating && dom.getAttribute('class') === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(hydrating && dom.getAttribute('class') !== next_class_name)\n\t) {\n\t\tif (next_class_name === '') {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tdom.setAttribute('class', next_class_name);\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @param {MathMLElement} dom\n * @param {string} value\n * @returns {void}\n */\nexport function set_mathml_class(dom, value) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev_class_name = dom.__className;\n\tvar next_class_name = to_class(value);\n\n\tif (hydrating && dom.getAttribute('class') === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(hydrating && dom.getAttribute('class') !== next_class_name)\n\t) {\n\t\tif (next_class_name === '') {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tdom.setAttribute('class', next_class_name);\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @param {HTMLElement} dom\n * @param {string} value\n * @returns {void}\n */\nexport function set_class(dom, value) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev_class_name = dom.__className;\n\tvar next_class_name = to_class(value);\n\n\tif (hydrating && dom.className === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(hydrating && dom.className !== next_class_name)\n\t) {\n\t\t// Removing the attribute when the value is only an empty string causes\n\t\t// peformance issues vs simply making the className an empty string. So\n\t\t// we should only remove the class if the the value is nullish.\n\t\tif (value == null) {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tdom.className = next_class_name;\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @template V\n * @param {V} value\n * @returns {string | V}\n */\nfunction to_class(value) {\n\treturn value == null ? '' : value;\n}\n\n/**\n * @param {Element} dom\n * @param {string} class_name\n * @param {boolean} value\n * @returns {void}\n */\nexport function toggle_class(dom, class_name, value) {\n\tif (value) {\n\t\tif (dom.classList.contains(class_name)) return;\n\t\tdom.classList.add(class_name);\n\t} else {\n\t\tif (!dom.classList.contains(class_name)) return;\n\t\tdom.classList.remove(class_name);\n\t}\n}\n","/** @import { ComponentContextLegacy } from '#client' */\nimport { run, run_all } from '../../../shared/utils.js';\nimport { derived } from '../../reactivity/deriveds.js';\nimport { user_pre_effect, user_effect } from '../../reactivity/effects.js';\nimport { component_context, deep_read_state, get, untrack } from '../../runtime.js';\n\n/**\n * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects\n * @param {boolean} [immutable]\n */\nexport function init(immutable = false) {\n\tconst context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\tconst callbacks = context.l.u;\n\tif (!callbacks) return;\n\n\tlet props = () => deep_read_state(context.s);\n\n\tif (immutable) {\n\t\tlet version = 0;\n\t\tlet prev = /** @type {Record<string, any>} */ ({});\n\n\t\t// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes\n\t\tconst d = derived(() => {\n\t\t\tlet changed = false;\n\t\t\tconst props = context.s;\n\t\t\tfor (const key in props) {\n\t\t\t\tif (props[key] !== prev[key]) {\n\t\t\t\t\tprev[key] = props[key];\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (changed) version++;\n\t\t\treturn version;\n\t\t});\n\n\t\tprops = () => get(d);\n\t}\n\n\t// beforeUpdate\n\tif (callbacks.b.length) {\n\t\tuser_pre_effect(() => {\n\t\t\tobserve_all(context, props);\n\t\t\trun_all(callbacks.b);\n\t\t});\n\t}\n\n\t// onMount (must run before afterUpdate)\n\tuser_effect(() => {\n\t\tconst fns = untrack(() => callbacks.m.map(run));\n\t\treturn () => {\n\t\t\tfor (const fn of fns) {\n\t\t\t\tif (typeof fn === 'function') {\n\t\t\t\t\tfn();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n\n\t// afterUpdate\n\tif (callbacks.a.length) {\n\t\tuser_effect(() => {\n\t\t\tobserve_all(context, props);\n\t\t\trun_all(callbacks.a);\n\t\t});\n\t}\n}\n\n/**\n * Invoke the getter of all signals associated with a component\n * so they can be registered to the effect this function is called in.\n * @param {ComponentContextLegacy} context\n * @param {(() => void)} props\n */\nfunction observe_all(context, props) {\n\tif (context.l.s) {\n\t\tfor (const signal of context.l.s) get(signal);\n\t}\n\n\tprops();\n}\n","/** @import { StoreReferencesContainer } from '#client' */\n/** @import { Store } from '#shared' */\nimport { subscribe_to_store } from '../../../store/utils.js';\nimport { noop } from '../../shared/utils.js';\nimport { get } from '../runtime.js';\nimport { teardown } from './effects.js';\nimport { mutable_source, set } from './sources.js';\n\n/**\n * Whether or not the prop currently being read is a store binding, as in\n * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in\n * runes mode, and skip `binding_property_non_reactive` validation\n */\nlet is_store_binding = false;\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\tconst entry = (stores[store_name] ??= {\n\t\tstore: null,\n\t\tsource: mutable_source(undefined),\n\t\tunsubscribe: noop\n\t});\n\n\tif (entry.store !== store) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\n\t\tif (store == null) {\n\t\t\tentry.source.v = undefined; // see synchronous callback comment below\n\t\t\tentry.unsubscribe = noop;\n\t\t} else {\n\t\t\tvar is_synchronous_callback = true;\n\n\t\t\tentry.unsubscribe = subscribe_to_store(store, (v) => {\n\t\t\t\tif (is_synchronous_callback) {\n\t\t\t\t\t// If the first updates to the store value (possibly multiple of them) are synchronously\n\t\t\t\t\t// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value\n\t\t\t\t\tentry.source.v = v;\n\t\t\t\t} else {\n\t\t\t\t\tset(entry.source, v);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tis_synchronous_callback = false;\n\t\t}\n\t}\n\n\treturn get(entry.source);\n}\n\n/**\n * Unsubscribe from a store if it's not the same as the one in the store references container.\n * We need this in addition to `store_get` because someone could unsubscribe from a store but\n * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully.\n * @param {Store<any> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n */\nexport function store_unsub(store, store_name, stores) {\n\t/** @type {StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\n\tif (entry && entry.store !== store) {\n\t\t// Don't reset store yet, so that store_get above can resubscribe to new store if necessary\n\t\tentry.unsubscribe();\n\t\tentry.unsubscribe = noop;\n\t}\n\n\treturn store;\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {StoreReferencesContainer} stores\n * @param {string} store_name\n */\nexport function invalidate_store(stores, store_name) {\n\tvar entry = stores[store_name];\n\tif (entry.store !== null) {\n\t\tstore_set(entry.store, entry.source.v);\n\t}\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @returns {StoreReferencesContainer}\n */\nexport function setup_stores() {\n\t/** @type {StoreReferencesContainer} */\n\tconst stores = {};\n\n\tteardown(() => {\n\t\tfor (var store_name in stores) {\n\t\t\tconst ref = stores[store_name];\n\t\t\tref.unsubscribe();\n\t\t}\n\t});\n\n\treturn stores;\n}\n\n/**\n * Updates a store with a new value.\n * @param {Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function store_mutate(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Called inside prop getters to communicate that the prop is a store binding\n */\nexport function mark_store_binding() {\n\tis_store_binding = true;\n}\n\n/**\n * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.\n * Used to prevent `binding_property_non_reactive` validation false positives and\n * ensure that these props are treated as mutable even in runes mode\n * @template T\n * @param {() => T} fn\n * @returns {[T, boolean]}\n */\nexport function capture_store_binding(fn) {\n\tvar previous_is_store_binding = is_store_binding;\n\n\ttry {\n\t\tis_store_binding = false;\n\t\treturn [fn(), is_store_binding];\n\t} finally {\n\t\tis_store_binding = previous_is_store_binding;\n\t}\n}\n","/** @import { Derived, Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { mutable_source, set, source } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tget,\n\tis_signals_recorded,\n\tset_active_effect,\n\tuntrack,\n\tupdate\n} from '../runtime.js';\nimport { safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { BRANCH_EFFECT, DESTROYED, LEGACY_DERIVED_PROP, ROOT_EFFECT } from '../constants.js';\nimport { proxy } from '../proxy.js';\nimport { capture_store_binding } from './store.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\ttarget.special[key] = prop(\n\t\t\t\t{\n\t\t\t\t\tget [key]() {\n\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/** @type {string} */ (key),\n\t\t\t\tPROPS_IS_UPDATED\n\t\t\t);\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tset(target, key, value) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tconst desc = get_descriptor(p, key);\n\t\t\tif (desc && desc.set) {\n\t\t\t\tdesc.set(value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nfunction with_parent_branch(fn) {\n\tvar effect = active_effect;\n\tvar previous_effect = active_effect;\n\n\twhile (effect !== null && (effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {\n\t\teffect = effect.parent;\n\t}\n\ttry {\n\t\tset_active_effect(effect);\n\t\treturn fn();\n\t} finally {\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\tvar is_store_sub = false;\n\tvar prop_value;\n\n\tif (bindable) {\n\t\t[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));\n\t} else {\n\t\tprop_value = /** @type {V} */ (props[key]);\n\t}\n\tvar setter = get_descriptor(props, key)?.set;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\tvar fallback_used = false;\n\n\tvar get_fallback = () => {\n\t\tfallback_used = true;\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\t\t\tif (lazy) {\n\t\t\t\tfallback_value = untrack(/** @type {() => V} */ (fallback));\n\t\t\t} else {\n\t\t\t\tfallback_value = /** @type {V} */ (fallback);\n\t\t\t}\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\tif (prop_value === undefined && fallback !== undefined) {\n\t\tif (setter && runes) {\n\t\t\te.props_invalid_value(key);\n\t\t}\n\n\t\tprop_value = get_fallback();\n\t\tif (setter) setter(prop_value);\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\tfallback_used = false;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\t\t// Replicate that behavior through using a derived\n\t\tvar derived_getter = with_parent_branch(() =>\n\t\t\t(immutable ? derived : derived_safe_equal)(() => /** @type {V} */ (props[key]))\n\t\t);\n\t\tderived_getter.f |= LEGACY_DERIVED_PROP;\n\t\tgetter = () => {\n\t\t\tvar value = get(derived_getter);\n\t\t\tif (value !== undefined) fallback_value = /** @type {V} */ (undefined);\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// easy mode — prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode — prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly — the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\n\tvar current_value = with_parent_branch(() =>\n\t\tderived(() => {\n\t\t\tvar parent_value = getter();\n\t\t\tvar child_value = get(inner_current_value);\n\t\t\tvar current_derived = /** @type {Derived} */ (active_reaction);\n\n\t\t\t// If the getter from the parent returns undefined, switch\n\t\t\t// to using the local value from inner_current_value instead,\n\t\t\t// as the parent value might have been torn down\n\t\t\tif (from_child || (parent_value === undefined && (current_derived.f & DESTROYED) !== 0)) {\n\t\t\t\tfrom_child = false;\n\t\t\t\twas_from_child = true;\n\t\t\t\treturn child_value;\n\t\t\t}\n\n\t\t\twas_from_child = false;\n\t\t\treturn (inner_current_value.v = parent_value);\n\t\t})\n\t);\n\n\tif (!immutable) current_value.equals = safe_equals;\n\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t// legacy nonsense — need to ensure the source is invalidated when necessary\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n\t\tif (is_signals_recorded) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tconst new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\n\n\t\t\tif (!current_value.equals(new_value)) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, new_value);\n\t\t\t\t// To ensure the fallback value is consistent when used with proxies, we\n\t\t\t\t// update the local fallback_value, but only if the fallback is actively used\n\t\t\t\tif (fallback_used && fallback_value !== undefined) {\n\t\t\t\t\tfallback_value = new_value;\n\t\t\t\t}\n\t\t\t\tuntrack(() => get(current_value)); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t\treturn get(current_value);\n\t};\n}\n","<script>\n    export let block;\n\n    // This function creates an optimized picture object\n    function createOptimizedPicture(src, alt, flag, sizes) {\n        return { src, alt, sizes };\n    }\n\n    // Helper function to determine the class name based on the content\n    function getClass(div) {\n        if (div.children.length === 1 && div.querySelector('picture')) {\n            return 'cards-card-image';\n        }\n        return 'cards-card-body';\n    }\n</script>\n\n<ul>\n    {#each block.children as row (row)}\n        <li>\n            {#each row.children as div (div)}\n                <div class={getClass(div)}>\n                    {#if div.querySelector('picture')}\n                        {#each Array.from(div.querySelectorAll('picture > img')) as img (img)}\n                            <picture>\n                                <img src={img.src} alt={img.alt} />\n                            </picture>\n                        {/each}\n                    {:else}\n                        {@html div.innerHTML}\n                    {/if}\n                </div>\n            {/each}\n        </li>\n    {/each}\n</ul>","import Card from './Card.svelte';\n\nexport default async function decorate(block) {\n    new Card({\n        target: block,\n    })\n}\n"],"names":["is_micro_task_queued","current_queued_micro_tasks","process_micro_tasks","tasks","run_all","queue_micro_task","fn","if_block","node","get_condition","consequent_fn","alternate_fn","elseif","hydrating","hydrate_next","anchor","consequent_effect","alternate_effect","condition","flags","EFFECT_TRANSPARENT","block","mismatch","is_else","HYDRATION_START_ELSE","remove_nodes","set_hydrate_node","set_hydrating","resume_effect","branch","pause_effect","hydrate_node","current_each_item","pause_effects","state","items","controlled_anchor","items_map","transitions","length","i","pause_children","is_controlled","parent_node","clear_text_content","link","run_out_transitions","item","destroy_effect","each","get_collection","get_key","render_fn","fallback_fn","EACH_IS_CONTROLLED","get_first_child","create_text","fallback","was_empty","collection","array","is_array","array_from","prev","HYDRATION_END","value","key","create_item","reconcile","is_animated","EACH_IS_ANIMATED","should_update","EACH_ITEM_REACTIVE","EACH_INDEX_REACTIVE","first","current","seen","to_animate","matched","stashed","_a","child_anchor","update_item","INERT","_b","start","j","a","b","move","to_destroy","destroy_length","_c","_d","active_effect","index","type","internal_set","next","previous_each_item","reactive","mutable","EACH_ITEM_IMMUTABLE","v","mutable_source","source","end","dest","next_node","get_next_sibling","set_class","dom","prev_class_name","next_class_name","to_class","init","immutable","context","component_context","callbacks","props","deep_read_state","version","d","derived","changed","get","user_pre_effect","observe_all","user_effect","fns","untrack","run","signal","is_store_binding","capture_store_binding","previous_is_store_binding","with_parent_branch","effect","previous_effect","BRANCH_EFFECT","ROOT_EFFECT","set_active_effect","prop","PROPS_IS_IMMUTABLE","runes","PROPS_IS_RUNES","is_store_sub","prop_value","setter","get_descriptor","fallback_value","fallback_dirty","get_fallback","e.props_invalid_value","getter","derived_getter","derived_safe_equal","LEGACY_DERIVED_PROP","$.prop","$$props","getClass","div","$.each","ul","row","li","$.get","class_derived","$.derived_safe_equal","node_1","img","$.set_attribute","img_1","$.html","node_2","decorate","Card"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}